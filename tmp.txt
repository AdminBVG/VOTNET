import { Component, AfterViewInit, ViewChild, inject, signal } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { HttpClient } from '@angular/common/http';
import { NgFor, NgIf, DecimalPipe, DatePipe, PercentPipe, NgClass, AsyncPipe } from '@angular/common';
import { ReactiveFormsModule, FormsModule, FormBuilder, Validators, FormControl } from '@angular/forms';
import { UiButtonDirective } from '../../ui/button.directive';
import { UiInputDirective } from '../../ui/input.directive';
import { UiSwitchComponent } from '../../ui/switch.component';
import { ToastService } from '../../ui/toast/toast.service';
import { LiveService } from '../../core/live.service';
import { AuthService } from '../../core/auth.service';
import { Roles, ALLOWED_ASSIGNMENT_ROLES } from '../../core/constants/roles';
import { FilterPresentPipe } from './filter-present.pipe';
import { Chart, registerables } from 'chart.js';

Chart.register(...registerables);

interface PadronRow { id: string; shareholderId: string; shareholderName: string; shares: number; attendance: string; }

@Component({
  selector: 'app-election-detail',
  standalone: true,
  imports: [NgFor, NgIf, DecimalPipe, DatePipe, PercentPipe, NgClass, ReactiveFormsModule, FormsModule, UiButtonDirective, UiInputDirective, UiSwitchComponent, FilterPresentPipe, AsyncPipe],
  template: `
  <div class="p-4 grid gap-4">
    <h2 *ngIf="!canRegister || editMode()" class="text-xl font-semibold">ElecciÃ³n {{id()}}</h2>
    <div class="rounded-xl border border-gray-200 bg-white shadow-card p-3">
      <div class="status-row">
        <span class="chip status">{{status()}}</span>
        <span class="chip" [ngClass]="statusLocked() ? 'locked' : 'unlocked'">{{ statusLocked() ? 'Registro bloqueado' : 'Registro abierto' }}</span>
        <span class="chip" [ngClass]="(quorum()?.quorum||0) >= ((electionInfo()?.quorumMinimo ?? electionInfo()?.QuorumMinimo) || 0) ? 'ok' : 'warn'">QuÃ³rum: {{ (quorum()?.quorum||0) | percent:'1.0-0' }}</span>
        <span class="muted">Fecha: {{ (electionInfo()?.scheduledAt ?? electionInfo()?.ScheduledAt) | date:'short' }}</span>
      </div>
    </div>

    <div *ngIf="editMode() && canClose && (!quorum() || (quorum()?.present||0) === 0)" class="rounded-xl border border-gray-200 bg-white shadow-card p-3">
      <h3 class="font-semibold">Editar configuraciÃ³n</h3>
      <form [formGroup]="editForm" (ngSubmit)="saveEdit()" class="edit-grid">
        <div>
          <label class="text-xs opacity-80">Nombre</label>
          <input uiInput formControlName="name">
        </div>
        <div>
          <label class="text-xs opacity-80">Fecha</label>
          <input uiInput type="date" [value]="editDate() | date:'yyyy-MM-dd'" (change)="onEditDate($any($event.target).valueAsDate || null)">
        </div>
        <div>
          <label class="text-xs opacity-80">Hora</label>
          <input uiInput type="time" [value]="editTime()" (input)="onEditTime($any($event.target).value)">
        </div>
        <div>
          <label class="text-xs opacity-80">QuÃ³rum mÃ­nimo (%)</label>
          <input uiInput type="number" min="0" max="100" formControlName="quorumPct">
        </div>
        <div *ngIf="canClose">
          <label class="text-xs opacity-80">Perfil de firma</label>
          <select uiInput [ngModel]="currentSigningProfile" (ngModelChange)="setSigningProfile($event)">
            <option [value]="">Sin perfil</option>
            <option *ngFor="let p of signingProfiles" [value]="p.alias">{{p.alias}} - {{p.subject || p.Subject}}</option>
          </select>
        </div>
        <div class="col-span-full flex items-center gap-2" *ngIf="canClose">
          <ui-switch [checked]="signingRequired" (checkedChange)="toggleSigning($event)"></ui-switch>
          <span class="text-sm">Requerir firma para certificar</span>
        </div>
        <div class="actions">
          <button uiBtn="secondary" type="button" (click)="cancelEdit()">Cancelar</button>
          <button uiBtn="primary" [disabled]="editForm.invalid">Guardar</button>
        </div>
      </form>
    </div>

    <div class="grid gap-4" *ngIf="!canRegister || editMode()">
      <div class="rounded-xl border border-gray-200 bg-white shadow-card p-3" *ngIf="!editMode()">
        <h3>Detalle</h3>
        <div *ngIf="electionInfo() as info" class="grid sm:grid-cols-2 gap-2">
          <div><b>Nombre:</b> {{ info.name ?? info.Name }}</div>
          <div><b>Detalles:</b> {{ info.details ?? info.Details }}</div>
          <div><b>Fecha:</b> {{ (info.scheduledAt ?? info.ScheduledAt) | date:'medium' }}</div>
          <div><b>QuÃ³rum mÃ­nimo:</b> {{ ((info.quorumMinimo ?? info.QuorumMinimo) * 100) | number:'1.0-0' }}%</div>
          <div><b>Perfil de firma:</b> {{ (info.signingProfile ?? info.SigningProfile) || 'Sin perfil' }}</div>
        </div>
      </div>

      <div class="rounded-xl border border-gray-200 bg-white shadow-card p-3" *ngIf="!editMode()">
        <h3>QuÃ³rum</h3>
        <div *ngIf="quorum() as q">
          Total: {{q.total}} | Presentes: {{q.present}} | %: {{(q.quorum*100) | number:'1.0-2'}}%
          <div class="h-2 bg-gray-200 rounded mt-1"><div class="h-2 bg-brand-primary rounded" [style.width.%]="q.quorum*100"></div></div>
        </div>
      </div>

      <div class="rounded-xl border border-gray-200 bg-white shadow-card p-3" *ngIf="editMode() && canClose">
        <h3>Asignaciones</h3>
        <form [formGroup]="assignForm" (ngSubmit)="addAssign()" class="assign-form">
          <div><label class="text-xs opacity-80">UserId</label><input uiInput formControlName="userId"></div>
          <div><label class="text-xs opacity-80">Rol</label><input uiInput formControlName="role" [placeholder]="assignmentRoles.join(' | ')"></div>
          <button uiBtn="primary" [disabled]="assignForm.invalid">Agregar</button>
        </form>
        <table class="w-full text-sm border border-gray-200 rounded-xl overflow-hidden mt-2" *ngIf="assignments().length">
          <thead class="bg-gray-50 text-gray-600"><tr><th class="p-2 text-left">Usuario</th><th class="p-2 text-left">Rol</th><th class="w-20"></th></tr></thead>
          <tbody>
            <tr *ngFor="let a of assignments()" class="border-t">
              <td class="p-2">{{a.userName || a.UserName || a.userId}}</td>
              <td class="p-2">{{a.role}}</td>
              <td class="p-2 text-right"><button uiBtn="danger" size="sm" (click)="removeAssign(a.id)">Quitar</button></td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="rounded-xl border border-gray-200 bg-white shadow-card p-3" *ngIf="!editMode()">
        <h3>Resultados</h3>
        <div *ngIf="!results().length">Sin datos / permisos.</div>
        <div *ngFor="let q of results(); let i = index" class="q">
          <h4 class="font-semibold">{{q.text}}</h4>
          <div class="chart-container"><canvas id="res-chart-{{i}}"></canvas></div>
          <table class="w-full text-sm border border-gray-200 rounded-xl overflow-hidden">
            <thead class="bg-gray-50 text-gray-600"><tr><th class="p-2 text-left">OpciÃ³n</th><th class="p-2 text-left">Votos</th><th class="p-2 text-left">%</th></tr></thead>
            <tbody>
              <tr *ngFor="let o of q.options" class="border-t">
                <td class="p-2">{{o.text}}</td>
                <td class="p-2">{{o.votes}}</td>
                <td class="p-2">{{ (o.percent || o.Percent)*100 | number:'1.0-2' }}%</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="rounded-xl border border-gray-200 bg-white shadow-card p-3" *ngIf="canRegister && !(electionInfo()?.isClosed)">
      <h3>Registrar votos</h3>
      <ng-container *ngIf="!showSummary(); else summaryTpl">
        <div class="progress font-semibold mb-2">Pregunta {{currentIndex()+1}} de {{results().length}}</div>
        <h4 class="font-semibold">{{currentQuestion()?.text}}</h4>
        <div class="mb-2">
          <label class="text-xs opacity-80">Aplicar a todos</label>
          <select uiInput class="full" [ngModel]="globalSelections[currentQuestionId()]" (ngModelChange)="applyAll($event)" aria-label="Aplicar opciÃ³n a todos">
            <option *ngFor="let o of getOptionsForCurrentQuestion()" [value]="o.optionId || o.OptionId">{{o.text}}</option>
          </select>
        </div>
        <table class="w-full text-sm border border-gray-200 rounded-xl overflow-hidden compact">
          <thead class="bg-gray-50 text-gray-600"><tr><th class="p-2 text-left">Accionista</th><th class="p-2 text-left">Acciones</th><th class="p-2 text-left">OpciÃ³n</th></tr></thead>
          <tbody>
            <tr *ngFor="let p of filteredPadron()" class="border-t">
              <td class="p-2">{{p.shareholderName}}</td>
              <td class="p-2">{{p.shares}}</td>
              <td class="p-2" [ngClass]="{'override': currentSelectionMap()[p.id] !== globalSelections[currentQuestionId()]}">
          <select uiInput [ngModel]="(electionInfo()?.signingProfile || electionInfo()?.SigningProfile) ?? '" (ngModelChange)="setSigningProfile($event)">
                  <option *ngFor="let o of getOptionsForCurrentQuestion()" [value]="o.optionId || o.OptionId">{{o.text}}</option>
                </select>
              </td>
            </tr>
          </tbody>
        </table>
        <div class="warn text-red-700 text-sm my-2" *ngIf="!canGoNext()">Debes registrar todos los votos antes de continuar.</div>
        <div class="vote-form flex items-center gap-2">
          <button uiBtn="secondary" (click)="prevQuestion()" [disabled]="currentIndex()===0" aria-label="Pregunta anterior">Anterior</button>
          <button uiBtn="primary" (click)="nextQuestion()" [disabled]="!canGoNext()" aria-label="Siguiente pregunta">{{currentIndex()+1 < results().length ? 'Siguiente' : 'Resumen'}}</button>
        </div>
      </ng-container>
      <ng-template #summaryTpl>
        <h4 class="font-semibold">Resumen de votos</h4>
        <div *ngFor="let q of results()" class="q">
          <h5 class="font-medium">{{q.text}}</h5>
          <div *ngFor="let o of (q.options ?? q.Options)" class="summary-option ml-3">{{o.text}}: {{summaryCount(q.questionId || q.QuestionId, o.optionId || o.OptionId)}}</div>
        </div>
        <div class="vote-form flex items-center gap-2">
          <button uiBtn="secondary" (click)="showSummary.set(false); currentIndex.set(0)">Editar</button>
          <button uiBtn="primary" (click)="submitAll()">Enviar votos</button>
        </div>
      </ng-template>
      <div class="mt8 mt-2" *ngIf="canClose && !showSummary()">
        <button uiBtn="secondary" (click)="closeVoting()" *ngIf="status()==='VotingOpen'">Cerrar votaciÃ³n</button>
        <button uiBtn="secondary" (click)="closeElection()">Cerrar elecciÃ³n</button>
      </div>
    </div>
  </div>
  `,
  styles: [`
     .grid{display:grid; gap:16px}
     .assign-form{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
     .q{margin-bottom:12px}
     .vote-form{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
     .full{width:100%}
     .mt8{margin-top:8px}
     table.compact th, table.compact td{ font-size:13px }
     .edit-grid{ display:grid; grid-template-columns: repeat(auto-fit, minmax(220px,1fr)); gap:12px; align-items:end }
     .actions{ grid-column: 1 / -1; display:flex; gap:8px; justify-content:flex-end }
     .progress{font-weight:600;margin-bottom:8px}
     .override select{background:#fff3cd}
     .summary-option{margin-left:12px}
     .warn{color:#d32f2f;font-size:13px;margin:4px 0}
     .chart-container{max-width:300px;margin-bottom:8px}
     .status-card{margin:12px 0;padding:8px 12px}
     .status-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
     .chip{border-radius:12px;padding:2px 8px;background:#eee}
     .chip.status{background:#e3f2fd}
     .chip.locked{background:#ffcdd2}
     .chip.unlocked{background:#c8e6c9}
     .chip.ok{background:#c8e6c9}
     .chip.warn{background:#ffe0b2}
     .muted{opacity:.8}
  `]
})
export class ElectionDetailComponent implements AfterViewInit {
  private route = inject(ActivatedRoute);
  private http = inject(HttpClient);
  private router = inject(Router);
  private toast = inject(ToastService);
  private live = inject(LiveService);
  private auth = inject(AuthService);

  id = signal<string>('');
  editMode = signal(false);
  editForm = inject(FormBuilder).group({ name:['', Validators.required], details:[''], quorumPct:[50, [Validators.min(0), Validators.max(100)]] });
  private editSelDate = signal<Date | null>(null);
  private editSelTime = signal<string>('09:00');
  padronUploading = signal(false);
  lastPadronFile: string | null = null;
  filteredPadron = signal<PadronRow[]>([]);
  padronAll: PadronRow[] = [];
  assignments = signal<any[]>([]);
  assignCols = ['userId','role','action'];
  resCols = ['text','votes','percent'];
  bulkCols = ['name','shares','vote'];
  results = signal<any[]>([]);
  quorum = signal<{total:number,present:number,quorum:number}|null>(null);
  status = signal<string>('Draft');
  statusLocked = signal<boolean>(false);
  electionInfo = signal<any|null>(null);

  padronCtrl = new FormControl<PadronRow | string>('', Validators.required);
  currentIndex = signal(0);
  showSummary = signal(false);
  globalSelections: Record<string,string> = {};
  voteSelections: Record<string, Record<string,string>> = {};
  charts: Chart[] = [];

  assignmentRoles = ALLOWED_ASSIGNMENT_ROLES;
  signingRequired: boolean = false;
  signingProfiles: any[] = [];

  constructor(){
    this.id.set(this.route.snapshot.params['id']);
    this.editMode.set(this.route.snapshot.queryParamMap.get('mode')==='edit');
    this.live.joinElection(this.id());
    if (this.editMode() && !(this.auth.hasRole('GlobalAdmin') || this.auth.hasRole('VoteAdmin'))) this.editMode.set(false);
    this.loadAssignments();
    this.loadResults();
    this.loadPadron();
    this.loadQuorum();
    this.loadElectionInfo();
    this.http.get<any>(`/api/elections/${this.id()}/status`).subscribe({ next: s => { const st = (s?.Status ?? s?.status ?? 'Draft'); const lck = !!(s?.Locked ?? s?.locked ?? false); this.status.set(st); this.statusLocked.set(lck); } });
    this.live.onVoteRegistered(()=> { this.loadResults(); this.loadQuorum(); });
    this.live.onQuorumUpdated(p => { if (p && p.ElectionId === this.id()) { this.quorum.set({ total: p.TotalShares, present: p.PresentShares, quorum: p.Quorum }); } });
    if (this.editMode()) this.prefillEdit();
    this.padronCtrl.valueChanges.subscribe(val => {
      const term = (typeof val === 'string' ? val : val?.shareholderName || '').toLowerCase();
      const base = this.padronAll.filter((p:PadronRow) => p.attendance === 'Presencial' || p.attendance === 'Virtual');
      this.filteredPadron.set(base.filter((p:PadronRow) => (p.shareholderName || '').toLowerCase().includes(term)));
    });
    this.loadSigningProfiles();
  }
  ngOnDestroy(){ this.live.leaveElection(this.id()); }
  ngAfterViewInit(){ }

  onPadron(e: Event){
    const input = e.target as HTMLInputElement;
    const file = input.files?.[0];
    if (!file) return;
    this.lastPadronFile = `${file.name} (${Math.round(file.size/1024)} KB)`;
    this.padronUploading.set(true);
    const fd = new FormData();
    fd.append('file', file);
    this.http.post(`/api/elections/${this.id()}/padron`, fd).subscribe({
      next: _=> { this.padronUploading.set(false); this.toast.show('PadrÃ³n cargado','success',2000); this.loadPadron(); },
      error: _=> { this.padronUploading.set(false); this.toast.show('Error al cargar padrÃ³n','error',3000); }
    });
  }

  loadAssignments(){ this.http.get<any[]>(`/api/elections/${this.id()}/assignments`).subscribe({ next: d=> this.assignments.set(d), error: _=> this.assignments.set([]) }); }
  addAssign(){ if (this.assignForm.invalid) return; this.http.post(`/api/elections/${this.id()}/assignments`, this.assignForm.value).subscribe({ next: _=> { this.assignForm.reset(); this.loadAssignments(); this.toast.show('AsignaciÃ³n creada','success',2000); }, error: _=> this.toast.show('Error al crear asignaciÃ³n','error',3000) }); }
  removeAssign(assignmentId: string){ this.http.delete(`/api/elections/${this.id()}/assignments/${assignmentId}`).subscribe({ next: _=> { this.loadAssignments(); this.toast.show('AsignaciÃ³n eliminada','success',2000); } }); }

  loadResults(){
    this.http.get<any[]>(`/api/elections/${this.id()}/results`).subscribe({
      next: d => { this.results.set(d as any[]); if(d && d.length){ this.currentIndex.set(0); this.showSummary.set(false); } setTimeout(()=>this.renderCharts(),0); },
      error: err => {
        if (err.status === 400) {
          this.http.get<any>(`/api/elections/${this.id()}`).subscribe({
            next: e => {
              const qs = (e?.questions ?? e?.Questions ?? []).map((q:any) => ({
                questionId: q.id ?? q.Id,
                text: q.text ?? q.Text,
                options: (q.options ?? q.Options ?? []).map((o:any)=>({ optionId: o.id ?? o.Id, text: o.text ?? o.Text, votes: 0 }))
              }));
              this.results.set(qs);
              if (qs.length) { this.currentIndex.set(0); this.showSummary.set(false); }
              setTimeout(()=>this.renderCharts(),0);
            },
            error: _ => { this.results.set([]); }
          });
        } else {
          this.results.set([]);
          if (err.status === 403) this.toast.show('No autorizado para ver resultados','error',2500);
        }
      }
    });
  }
  toggleSigning(state: boolean){ this.signingRequired = !!state; this.http.put(`/api/elections/${this.id()}`, { signingRequired: this.signingRequired }).subscribe({ next: _=> this.toast.show('Firma requerida actualizada','success',1500), error: _=> this.toast.show('No se pudo actualizar firma requerida','error',2000) }); }
  loadElectionInfo(){ this.http.get<any>(`/api/elections/${this.id()}`).subscribe({ next: e => this.electionInfo.set(e || null), error: _ => this.electionInfo.set(null) }); }
  loadPadron(){ this.http.get<any[]>(`/api/elections/${this.id()}/padron`).subscribe({ next: d=> { this.padronAll = d; this.filteredPadron.set(this.padronAll.filter(p => p.attendance === 'Presencial' || p.attendance === 'Virtual')); this.padronCtrl.setValue(this.padronCtrl.value || ''); }, error: _=> { this.padronAll = []; this.filteredPadron.set([]); } }); }
  loadQuorum(){ this.http.get<any>(`/api/elections/${this.id()}/quorum`).subscribe({ next: d=> { const q = { total: d.total ?? d.Total, present: d.present ?? d.Present, quorum: d.quorum ?? d.Quorum } as {total:number,present:number,quorum:number}; this.quorum.set(q); if (this.editMode() && (q.present ?? 0) > 0){ this.editMode.set(false); this.toast.show('No se puede editar: ya hay registros de asistencia','warning',2500); this.router.navigate(['/elections', this.id()]); } }, error: _=> {} }); }

  assignForm = inject(FormBuilder).group({ userId: ['', Validators.required], role: ['', Validators.required] });

  prefillEdit(){ const e = this.electionInfo(); if (!e) return; this.editForm.patchValue({ name: e.name ?? e.Name, details: e.details ?? e.Details, quorumPct: Math.round(((e.quorumMinimo ?? e.QuorumMinimo) || 0)*100) }); const dt = new Date(e.scheduledAt ?? e.ScheduledAt); this.editSelDate.set(dt); const hh = dt.getHours().toString().padStart(2,'0'); const mm = dt.getMinutes().toString().padStart(2,'0'); this.editSelTime.set(`${hh}:${mm}`); this.signingRequired = !!(e.signingRequired ?? e.SigningRequired); }
  cancelEdit(){ this.editMode.set(false); }
  editDate(){ return this.editSelDate(); }
  editTime(){ return this.editSelTime(); }
  onEditDate(d: Date | null){ this.editSelDate.set(d); }
  onEditTime(v: string){ this.editSelTime.set(v); }
  saveEdit(){ if (this.editForm.invalid) return; const e = this.editForm.value as any; const dt = this.editSelDate(); const tm = this.editSelTime(); let scheduledAt = this.electionInfo()?.scheduledAt ?? this.electionInfo()?.ScheduledAt; try { if (dt && tm){ const [hh,mm] = (tm||'09:00').split(':'); const d2 = new Date(dt); d2.setHours(parseInt(hh||'9')||9, parseInt(mm||'0')||0, 0, 0); scheduledAt = d2.toISOString(); } } catch {} const dto:any = { name: e.name, details: e.details, scheduledAt, quorumMinimo: Math.min(1, Math.max(0, (Number(e.quorumPct)||0)/100)) }; this.http.put(`/api/elections/${this.id()}`, dto).subscribe({ next: _=> { this.toast.show('Guardado','success',1500); this.loadElectionInfo(); }, error: _=> this.toast.show('Error al guardar','error',2000) }); }

  loadSigningProfiles(){ this.http.get<any[]>(`/api/signing/profiles`).subscribe({ next: d=> this.signingProfiles = d || [], error: _=> this.signingProfiles = [] }); }
  setSigningProfile(alias: string){ this.http.put(`/api/elections/${this.id()}`, { signingProfile: alias }).subscribe({ next: _=> { this.toast.show('Perfil de firma actualizado','success',1500); this.loadElectionInfo(); }, error: _=> this.toast.show('No se pudo actualizar perfil','error',2000) }); }

  currentQuestionId(){ return this.results()[this.currentIndex()]?.questionId ?? this.results()[this.currentIndex()]?.QuestionId; }
  currentQuestion(){ return this.results()[this.currentIndex()]; }
  getOptionsForCurrentQuestion(){ return this.currentQuestion()?.options ?? this.currentQuestion()?.Options ?? []; }
  currentSelectionMap(){ const qId = this.currentQuestionId(); return this.voteSelections[qId] || (this.voteSelections[qId] = {}); }
  applyAll(optionId: string){ const map = this.currentSelectionMap(); this.globalSelections[this.currentQuestionId()] = optionId; for (const p of this.filteredPadron()) map[p.id] = optionId; }
  canGoNext(){ const map = this.currentSelectionMap(); return this.filteredPadron().every(p => !!map[p.id]); }
  nextQuestion(){ if (!this.canGoNext()){ this.toast.show('Faltan votos por registrar','warning',2500); return; } if (this.currentIndex() < this.results().length - 1) this.currentIndex.update(i=>i+1); else this.showSummary.set(true); }
  prevQuestion(){ if (this.currentIndex() > 0) this.currentIndex.update(i=>i-1); }
  summaryCount(qId:string, optionId:string){ const map = this.voteSelections[qId] || {}; return Object.values(map).filter(v=>v===optionId).length; }
  renderCharts(){ this.charts.forEach(c=>c.destroy()); this.charts = []; this.results().forEach((q:any, idx:number) => { const canvas = document.getElementById(`res-chart-${idx}`) as HTMLCanvasElement | null; if (!canvas) return; const opts = q.options ?? q.Options ?? []; const labels = opts.map((o:any)=>o.text); const data = opts.map((o:any)=>o.votes); const colors = labels.map((_:any,i:number)=>`hsl(${(i*60)%360},70%,70%)`); this.charts.push(new Chart(canvas,{type:'pie', data:{labels, datasets:[{data, backgroundColor:colors}]}})); }); }
  submitAll(){ const votes:any[] = []; for (const q of this.results()){ const qId = q.questionId || q.QuestionId; const map = this.voteSelections[qId] || {}; for (const pid of Object.keys(map)) votes.push({ padronId: pid, questionId: qId, optionId: map[pid] }); } if (!votes.length){ this.toast.show('No hay votos para registrar','warning',2000); return; } const onSuccess = () => { this.toast.show('Votos registrados','success',1500); this.loadResults(); this.voteSelections = {}; this.globalSelections = {}; this.showSummary.set(false); this.currentIndex.set(0); }; this.http.post(`/api/elections/${this.id()}/votes/batch`, { votes }).subscribe({ next: _=> onSuccess(), error: err => { if (err.status === 501){ const calls = votes.map(v => this.http.post(`/api/elections/${this.id()}/votes`, v)); Promise.all(calls.map(x=>x.toPromise())).then(()=> onSuccess()).catch(()=> this.toast.show('Error al registrar voto','error',2500)); } else if (err.status === 404) this.toast.show('ElecciÃ³n no encontrada','error',2500); else if (err.status === 400) this.toast.show('QuÃ³rum no alcanzado o elecciÃ³n cerrada','error',2500); else if (err.status === 403) this.toast.show('No tienes permiso para registrar','error',2500); else this.toast.show('Error al registrar voto','error',2500); } }); }
  closeElection(){ this.http.post(`/api/elections/${this.id()}/close`, {}).subscribe({ next: _=> { this.toast.show('ElecciÃ³n cerrada','success',2000); this.loadResults(); this.loadElectionInfo(); }, error: _=> this.toast.show('No autorizado para cerrar','error',2500) }); }
  get canAttend(){ if (this.auth.hasRole('GlobalAdmin') || this.auth.hasRole('VoteAdmin')) return true; const me = this.auth.payload?.sub; return (this.assignments()||[]).some((a:any) => (a.userId ?? a.UserId) === me && (a.role ?? a.Role) === Roles.AttendanceRegistrar); }
  get canRegister(){ if (this.electionInfo()?.isClosed) return false; const admin = this.auth.hasRole('GlobalAdmin') || this.auth.hasRole('VoteAdmin'); if (!admin && this.status() !== "VotingOpen") return false; if (admin) return true; const me = this.auth.payload?.sub; return (this.assignments()||[]).some((a:any) => (a.userId ?? a.UserId) === me && (a.role ?? a.Role) === Roles.VoteRegistrar); }
  get canClose(){ return this.auth.hasRole('GlobalAdmin') || this.auth.hasRole('VoteAdmin'); }
  closeVoting(){ this.http.post('/api/elections/' + this.id() + '/status/close-voting', { confirm: true }).subscribe({ next: _=> { this.toast.show('VotaciÃ³n cerrada','success',2000); this.loadResults(); this.loadQuorum(); }, error: err => { if (err?.error?.error === 'incomplete_votes') this.toast.show('Faltan votos de presentes en alguna pregunta','error',2500); else this.toast.show('No se pudo cerrar la votaciÃ³n','error',2500); } }); }
}

